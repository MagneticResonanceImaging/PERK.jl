<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Methods · PERK.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://StevenWhitaker.github.io/PERK.jl/stable/methods/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">PERK.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Methods</a><ul class="internal"><li><a class="tocitem" href="#Methods-list"><span>Methods list</span></a></li><li><a class="tocitem" href="#Methods-usage"><span>Methods usage</span></a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../generated/examples/01-overview/">PERK overview</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Methods</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Methods</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/StevenWhitaker/PERK.jl/blob/main/docs/src/methods.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h2 id="Methods-list"><a class="docs-heading-anchor" href="#Methods-list">Methods list</a><a id="Methods-list-1"></a><a class="docs-heading-anchor-permalink" href="#Methods-list" title="Permalink"></a></h2><ul><li><a href="#PERK.PERK"><code>PERK.PERK</code></a></li><li><a href="#PERK.EuclideanKernel"><code>PERK.EuclideanKernel</code></a></li><li><a href="#PERK.EuclideanKernel-Tuple{AbstractMatrix{&lt;:Real}, AbstractMatrix{&lt;:Real}}"><code>PERK.EuclideanKernel</code></a></li><li><a href="#PERK.ExactKernel"><code>PERK.ExactKernel</code></a></li><li><a href="#PERK.ExactTrainingData"><code>PERK.ExactTrainingData</code></a></li><li><a href="#PERK.GaussianKernel"><code>PERK.GaussianKernel</code></a></li><li><a href="#PERK.GaussianKernel-Tuple{AbstractMatrix{&lt;:Real}, AbstractMatrix{&lt;:Real}}"><code>PERK.GaussianKernel</code></a></li><li><a href="#PERK.GaussianKernel-Tuple{Union{Complex, AbstractVector{&lt;:Complex}}}"><code>PERK.GaussianKernel</code></a></li><li><a href="#PERK.GaussianRFF-Tuple{Integer, Union{Complex, AbstractVector{&lt;:Complex}}}"><code>PERK.GaussianRFF</code></a></li><li><a href="#PERK.GaussianRFF-Tuple{Random.AbstractRNG, AbstractMatrix{&lt;:Real}}"><code>PERK.GaussianRFF</code></a></li><li><a href="#PERK.GaussianRFF"><code>PERK.GaussianRFF</code></a></li><li><a href="#PERK.Kernel"><code>PERK.Kernel</code></a></li><li><a href="#PERK.RFFKernel"><code>PERK.RFFKernel</code></a></li><li><a href="#PERK.RFFTrainingData"><code>PERK.RFFTrainingData</code></a></li><li><a href="#PERK.TrainingData"><code>PERK.TrainingData</code></a></li><li><a href="#PERK.addnoise!-Tuple{Any, Any, Any}"><code>PERK.addnoise!</code></a></li><li><a href="#PERK.combine-Tuple{AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}}"><code>PERK.combine</code></a></li><li><a href="#PERK.complex2real-Tuple{Complex}"><code>PERK.complex2real</code></a></li><li><a href="#PERK.div0-Tuple{Number, Number}"><code>PERK.div0</code></a></li><li><a href="#PERK.gaussiankernel-Tuple{Any, Any, Any}"><code>PERK.gaussiankernel</code></a></li><li><a href="#PERK.generatenoisydata-Tuple{Random.AbstractRNG, Integer, Any, Any, Union{Function, AbstractVector{&lt;:Function}}}"><code>PERK.generatenoisydata</code></a></li><li><a href="#PERK.holdout-Tuple{Random.AbstractRNG, Integer, Integer, AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}, AbstractVector, AbstractVector, Any, Union{Function, AbstractVector{&lt;:Function}}, Function}"><code>PERK.holdout</code></a></li><li><a href="#PERK.krr-Tuple{Union{Real, AbstractMatrix{&lt;:Real}, AbstractVector{&lt;:Real}}, PERK.ExactTrainingData, PERK.ExactKernel}"><code>PERK.krr</code></a></li><li><a href="#PERK.krr_train-Tuple{AbstractVector{&lt;:Real}, Union{AbstractMatrix{&lt;:Real}, AbstractVector{&lt;:Real}}, PERK.ExactKernel, Real}"><code>PERK.krr_train</code></a></li><li><a href="#PERK.perk-Tuple{Random.AbstractRNG, Union{Number, AbstractMatrix{&lt;:Number}, AbstractVector{&lt;:Number}}, Integer, Any, Any, Union{Function, AbstractVector{&lt;:Function}}, PERK.Kernel, Real}"><code>PERK.perk</code></a></li><li><a href="#PERK.perk-Tuple{Union{Number, AbstractMatrix{&lt;:Number}, AbstractVector{&lt;:Number}}, PERK.TrainingData, PERK.Kernel}"><code>PERK.perk</code></a></li><li><a href="#PERK.rffmap-Tuple{AbstractMatrix{&lt;:Real}, AbstractMatrix{&lt;:Real}, AbstractVector{&lt;:Real}}"><code>PERK.rffmap</code></a></li><li><a href="#PERK.train-Tuple{Random.AbstractRNG, Integer, Any, Any, Union{Function, AbstractVector{&lt;:Function}}, PERK.Kernel, Real}"><code>PERK.train</code></a></li></ul><h2 id="Methods-usage"><a class="docs-heading-anchor" href="#Methods-usage">Methods usage</a><a id="Methods-usage-1"></a><a class="docs-heading-anchor-permalink" href="#Methods-usage" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PERK.PERK" href="#PERK.PERK"><code>PERK.PERK</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">PERK</code></pre><p>Module implementing parameter estimation via regression with kernels (PERK).</p><p><strong>Exports</strong></p><ul><li><code>EuclideanKernel</code>: Euclidean inner product kernel (for ridge regression instead of kernel ridge regression)</li><li><code>GaussianKernel</code>: Gaussian kernel used in kernel ridge regression</li><li><code>GaussianRFF</code>: Approximation of Gaussian kernel using random Fourier features</li><li><code>generatenoisydata</code>: Function for generating noisy data</li><li><code>perk</code>: Function for running PERK</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StevenWhitaker/PERK.jl/blob/2780883ddfbe65d460b42dc4e89bbb9a9454a97c/src/PERK.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PERK.EuclideanKernel" href="#PERK.EuclideanKernel"><code>PERK.EuclideanKernel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EuclideanKernel() &lt;: ExactKernel</code></pre><p>Create a kernel function where the kernel is just the Euclidean inner product (i.e., ridge regression).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StevenWhitaker/PERK.jl/blob/2780883ddfbe65d460b42dc4e89bbb9a9454a97c/src/kernels.jl#L24-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PERK.EuclideanKernel-Tuple{AbstractMatrix{&lt;:Real}, AbstractMatrix{&lt;:Real}}" href="#PERK.EuclideanKernel-Tuple{AbstractMatrix{&lt;:Real}, AbstractMatrix{&lt;:Real}}"><code>PERK.EuclideanKernel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(k::EuclideanKernel)(p, q)</code></pre><p>Evaluate the Euclidean inner product between <code>p</code> and <code>q</code>.</p><p><strong>Arguments</strong></p><ul><li><code>p::Union{&lt;:Real,&lt;:AbstractVector{&lt;:Real},&lt;:AbstractMatrix{&lt;:Real}}</code>: First kernel input [Q,M] or [M] (if Q = 1) or scalar (if Q = M = 1)</li><li><code>q::Union{&lt;:Real,&lt;:AbstractVector{&lt;:Real},&lt;:AbstractMatrix{&lt;:Real}}</code>: Second kernel input [Q,N] or [N] (if Q = 1) or scalar (if Q = N = 1)</li></ul><p><strong>Note</strong></p><ul><li>Q is the number of features</li><li>M is the number of feature vectors in the first input</li><li>N is the number of feature vectors in the second input</li></ul><p><strong>Return</strong></p><ul><li><code>K::Union{&lt;:Real,&lt;:AbstractVector{&lt;:Real},&lt;:AbstractMatrix{&lt;:Real}}</code>: Kernel output [M,N] or [M] (if N = 1) or [N] (if M = 1) or scalar (if M = N = 1)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StevenWhitaker/PERK.jl/blob/2780883ddfbe65d460b42dc4e89bbb9a9454a97c/src/kernels.jl#L32-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PERK.ExactKernel" href="#PERK.ExactKernel"><code>PERK.ExactKernel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ExactKernel &lt;: Kernel</code></pre><p>Abstract type for representing kernels that are evaluated exactly. <code>ExactKernel</code>s must be callable with two inputs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StevenWhitaker/PERK.jl/blob/2780883ddfbe65d460b42dc4e89bbb9a9454a97c/src/kernels.jl#L8-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PERK.ExactTrainingData" href="#PERK.ExactTrainingData"><code>PERK.ExactTrainingData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ExactTrainingData(y, x, xm, K, Km, xKinv) &lt;: TrainingData</code></pre><p>Create an object that contains the training data when using the full Gram matrix K.</p><p><strong>Properties</strong></p><ul><li><code>y::Union{&lt;:AbstractVector{&lt;:Real},&lt;:AbstractMatrix{&lt;:Real}}</code>: Features for training data [Q,T] or [T] (if Q = 1)</li><li><code>x::Union{&lt;:AbstractVector{&lt;:Real},&lt;:AbstractMatrix{&lt;:Real}}</code>: Latent parameters for training data [L,T] or [T] (if L = 1)</li><li><code>xm::Union{&lt;:Real,&lt;:AbstractVector{&lt;:Real}}</code>: Mean of latent parameters [L] or scalar (if L = 1)</li><li><code>K::AbstractMatrix{&lt;:Real}</code>: De-meaned (both rows and columns) Gram matrix of the kernel evaluated on the training data features [T,T]</li><li><code>Km::AbstractVector{&lt;:Real}</code>: Row means of <code>K</code> (before de-meaning) [T]</li><li><code>xKinv::Union{&lt;:AbstractVector{&lt;:Real},&lt;:AbstractMatrix{&lt;:Real}}</code>: <code>x</code> times the regularized inverse of <code>K</code> [L,T] or [T] (if L = 1)</li><li><code>Q::Integer</code>: Number of training features</li><li><code>L::Integer</code>: Number of latent parameters</li><li><code>T::Integer</code>: Number of training points</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StevenWhitaker/PERK.jl/blob/2780883ddfbe65d460b42dc4e89bbb9a9454a97c/src/training.jl#L8-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PERK.GaussianKernel" href="#PERK.GaussianKernel"><code>PERK.GaussianKernel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GaussianKernel(Λ) &lt;: ExactKernel</code></pre><p>Create a Gaussian kernel function.</p><p><strong>Properties</strong></p><ul><li><code>Λ::Union{&lt;:Real,AbstractVector{&lt;:Real}}</code>: Length scales [Q] or scalar (if Q = 1)</li></ul><p><strong>Note</strong></p><ul><li>Q is the number of features</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StevenWhitaker/PERK.jl/blob/2780883ddfbe65d460b42dc4e89bbb9a9454a97c/src/kernels.jl#L116-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PERK.GaussianKernel-Tuple{AbstractMatrix{&lt;:Real}, AbstractMatrix{&lt;:Real}}" href="#PERK.GaussianKernel-Tuple{AbstractMatrix{&lt;:Real}, AbstractMatrix{&lt;:Real}}"><code>PERK.GaussianKernel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(k::GaussianKernel)(p, q)</code></pre><p>Evaluate the Gaussian kernel.</p><p><strong>Arguments</strong></p><ul><li><code>p::Union{&lt;:Real,&lt;:AbstractVector{&lt;:Real},&lt;:AbstractMatrix{&lt;:Real}}</code>: First kernel input [Q,M] or [M] (if Q = 1) or scalar (if Q = M = 1)</li><li><code>q::Union{&lt;:Real,&lt;:AbstractVector{&lt;:Real},&lt;:AbstractMatrix{&lt;:Real}}</code>: Second kernel input [Q,N] or [N] (if Q = 1) or scalar (if Q = N = 1)</li></ul><p><strong>Note</strong></p><ul><li>Q is the number of features</li><li>M is the number of feature vectors in the first input</li><li>N is the number of feature vectors in the second input</li></ul><p><strong>Return</strong></p><ul><li><code>K::Union{&lt;:Real,&lt;:AbstractVector{&lt;:Real},&lt;:AbstractMatrix{&lt;:Real}}</code>: Kernel output [M,N] or [M] (if N = 1) or [N] (if M = 1) or scalar (if M = N = 1)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StevenWhitaker/PERK.jl/blob/2780883ddfbe65d460b42dc4e89bbb9a9454a97c/src/kernels.jl#L171-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PERK.GaussianKernel-Tuple{Union{Complex, AbstractVector{&lt;:Complex}}}" href="#PERK.GaussianKernel-Tuple{Union{Complex, AbstractVector{&lt;:Complex}}}"><code>PERK.GaussianKernel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">GuassianKernel(Λy, [Λν])</code></pre><p>Create a Guassian kernel function.</p><p><strong>Arguments</strong></p><ul><li><code>Λy::Union{&lt;:Number,&lt;:AbstractVector{&lt;:Number}}</code>: Length scales for features [Q] or scalar (if Q = 1)</li><li><code>Λν::Union{&lt;:Real,&lt;:AbstractVector{&lt;:Real}}</code>: Length scales for known parameters [K] or scalar (if K = 1)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StevenWhitaker/PERK.jl/blob/2780883ddfbe65d460b42dc4e89bbb9a9454a97c/src/kernels.jl#L137-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PERK.GaussianRFF" href="#PERK.GaussianRFF"><code>PERK.GaussianRFF</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GaussianRFF(H, Λ) &lt;: RFFKernel</code></pre><p>Create an approximate (via random Fourier features) Gaussian kernel function.</p><p><strong>Properties</strong></p><ul><li><code>H::Integer</code>: Approximation order</li><li><code>Λ::Union{&lt;:Real,AbstractVector{&lt;:Real}}</code>: Length scales [Q] or scalar (if Q = 1)</li></ul><p><strong>Note</strong></p><ul><li>Q is the number of features</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StevenWhitaker/PERK.jl/blob/2780883ddfbe65d460b42dc4e89bbb9a9454a97c/src/kernels.jl#L290-L302">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PERK.GaussianRFF-Tuple{Integer, Union{Complex, AbstractVector{&lt;:Complex}}}" href="#PERK.GaussianRFF-Tuple{Integer, Union{Complex, AbstractVector{&lt;:Complex}}}"><code>PERK.GaussianRFF</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">GuassianRFF(H, Λy, [Λν])</code></pre><p>Create an approximate (via random Fourier features) Gaussian kernel function.</p><p><strong>Arguments</strong></p><ul><li><code>H::Integer</code>: Approximation order</li><li><code>Λy::Union{&lt;:Number,&lt;:AbstractVector{&lt;:Number}}</code>: Length scales for features [Q] or scalar (if Q = 1)</li><li><code>Λν::Union{&lt;:Real,&lt;:AbstractVector{&lt;:Real}}</code>: Length scales for known parameters [K] or scalar (if K = 1)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StevenWhitaker/PERK.jl/blob/2780883ddfbe65d460b42dc4e89bbb9a9454a97c/src/kernels.jl#L313-L324">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PERK.GaussianRFF-Tuple{Random.AbstractRNG, AbstractMatrix{&lt;:Real}}" href="#PERK.GaussianRFF-Tuple{Random.AbstractRNG, AbstractMatrix{&lt;:Real}}"><code>PERK.GaussianRFF</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(k::GaussianRFF)([rng], q)
(k::GaussianRFF)(q, f, phase)</code></pre><p>Evaluate the approximate Gaussian kernel.</p><p><strong>Arguments</strong></p><ul><li><code>rng::AbstractRNG = Random.GLOBAL_RNG</code>: Random number generator to use to generate <code>f</code> and <code>phase</code></li><li><code>q::Union{&lt;:Real,&lt;:AbstractVector{&lt;:Real},&lt;:AbstractMatrix{&lt;:Real}}</code>: Kernel input [Q,N] or [N] (if Q = 1) or scalar (if Q = N = 1)</li><li><code>f::Union{&lt;:AbstractVector{&lt;:Real},&lt;:AbstractMatrix{&lt;:Real}} = randn(k.H, Q)</code>: Unscaled random frequency values [H,Q] or [H] (if Q = 1)</li><li><code>phase::AbstractVector{&lt;:Real} = rand(k.H)</code>: Random phase values [H]</li></ul><p><strong>Note</strong></p><ul><li>Q is the number of features</li><li>N is the number of feature vectors in the input</li><li>H is the approximation order for the random Fourier features</li></ul><p><strong>Return</strong></p><ul><li><code>z::Union{&lt;:AbstractVector{&lt;:Real},&lt;:AbstractMatrix{&lt;:Real}}</code>: Higher-dimensional features [H,N] or [H] (if N = 1)</li><li><code>freq::Union{&lt;:AbstractVector{&lt;:Real},&lt;:AbstractMatrix{&lt;:Real}}</code>: Random frequency values [H,Q] or [H] (if Q = 1)</li><li><code>phase::AbstractVector{&lt;:Real}</code>: Random phase values [H]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StevenWhitaker/PERK.jl/blob/2780883ddfbe65d460b42dc4e89bbb9a9454a97c/src/kernels.jl#L350-L376">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PERK.Kernel" href="#PERK.Kernel"><code>PERK.Kernel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Kernel</code></pre><p>Abstract type for representing kernel functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StevenWhitaker/PERK.jl/blob/2780883ddfbe65d460b42dc4e89bbb9a9454a97c/src/kernels.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PERK.RFFKernel" href="#PERK.RFFKernel"><code>PERK.RFFKernel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RFFKernel &lt;: Kernel</code></pre><p>Abstract type for representing kernels that are approximated via random Fourier features. <code>RFFKernel</code>s must be callable with one or three inputs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StevenWhitaker/PERK.jl/blob/2780883ddfbe65d460b42dc4e89bbb9a9454a97c/src/kernels.jl#L16-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PERK.RFFTrainingData" href="#PERK.RFFTrainingData"><code>PERK.RFFTrainingData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RFFTrainingData(freq, phase, zm, xm, Czz, Cxz, CxzCzzinv) &lt;: TrainingData</code></pre><p>Create an object that contains the training data when using an approximation of the Gram matrix K using random Fourier features.</p><p><strong>Properties</strong></p><ul><li><code>freq::Union{&lt;:AbstractVector{&lt;:Real},&lt;:AbstractMatrix{&lt;:Real}}</code>: Random frequency values for random Fourier features [H,Q] or [H] (if Q = 1)</li><li><code>phase::AbstractVector{&lt;:Real}</code>: Random phase values for random Fourier features [H]</li><li><code>zm::AbstractVector{&lt;:Real}</code>: Mean of feature maps [H]</li><li><code>xm::Union{&lt;:Real,&lt;:AbstractVector{&lt;:Real}}</code>: Mean of latent parameters [L] or scalar (if L = 1)</li><li><code>Czz::AbstractMatrix{&lt;:Real}</code>: Auto-covariance matrix of feature maps [H,H]</li><li><code>Cxz::Union{&lt;:AbstractVector{&lt;:Real},&lt;:AbstractMatrix{&lt;:Real}}</code>: Cross-covariance matrix between latent parameters and feature maps [L,H] or [H] (if L = 1)</li><li><code>CxzCzzinv::Union{&lt;:AbstractVector{&lt;:Real},&lt;:AbstractMatrix{&lt;:Real}}</code>: <code>Cxz</code> times the regularized inverse of <code>Czz</code> [L,H] or [H] (if L = 1)</li><li><code>Q::Integer</code>: Number of training features</li><li><code>L::Integer</code>: Number of latent parameters</li><li><code>H::Integer</code>: Kernel approximation order</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StevenWhitaker/PERK.jl/blob/2780883ddfbe65d460b42dc4e89bbb9a9454a97c/src/training.jl#L60-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PERK.TrainingData" href="#PERK.TrainingData"><code>PERK.TrainingData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TrainingData</code></pre><p>Abstract type for representing training data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StevenWhitaker/PERK.jl/blob/2780883ddfbe65d460b42dc4e89bbb9a9454a97c/src/training.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PERK.addnoise!-Tuple{Any, Any, Any}" href="#PERK.addnoise!-Tuple{Any, Any, Any}"><code>PERK.addnoise!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">addnoise!([rng], y, noiseDist)</code></pre><p>Add noise to <code>y</code>. If elements of <code>y</code> are complex-valued, then add independent noise to both the real and imaginary parts of <code>y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StevenWhitaker/PERK.jl/blob/2780883ddfbe65d460b42dc4e89bbb9a9454a97c/src/training.jl#L467-L472">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PERK.combine-Tuple{AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}}" href="#PERK.combine-Tuple{AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}}"><code>PERK.combine</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">combine(y, ν)</code></pre><p>Combine the output of the signal models with the known parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StevenWhitaker/PERK.jl/blob/2780883ddfbe65d460b42dc4e89bbb9a9454a97c/src/training.jl#L221-L225">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PERK.complex2real-Tuple{Complex}" href="#PERK.complex2real-Tuple{Complex}"><code>PERK.complex2real</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">complex2real(y)</code></pre><p>Split complex data into real and imaginary parts.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StevenWhitaker/PERK.jl/blob/2780883ddfbe65d460b42dc4e89bbb9a9454a97c/src/training.jl#L192-L196">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PERK.div0-Tuple{Number, Number}" href="#PERK.div0-Tuple{Number, Number}"><code>PERK.div0</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">div0(a, b)</code></pre><p>Compute <code>a / b</code>, but return 0 if <code>b</code> is 0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StevenWhitaker/PERK.jl/blob/2780883ddfbe65d460b42dc4e89bbb9a9454a97c/src/utils.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PERK.gaussiankernel-Tuple{Any, Any, Any}" href="#PERK.gaussiankernel-Tuple{Any, Any, Any}"><code>PERK.gaussiankernel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gaussiankernel(p, q, sqrtΣ)</code></pre><p>Compute the Gaussian kernel with covariance matrix Σ evaluated at <code>p</code> and <code>q</code>. Note that function input is <code>sqrtΣ</code>, i.e., the square root of Σ.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StevenWhitaker/PERK.jl/blob/2780883ddfbe65d460b42dc4e89bbb9a9454a97c/src/kernels.jl#L278-L283">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PERK.generatenoisydata-Tuple{Random.AbstractRNG, Integer, Any, Any, Union{Function, AbstractVector{&lt;:Function}}}" href="#PERK.generatenoisydata-Tuple{Random.AbstractRNG, Integer, Any, Any, Union{Function, AbstractVector{&lt;:Function}}}"><code>PERK.generatenoisydata</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">generatenoisydata([rng], N, xDists, [νDists], noiseDist, signalModels)</code></pre><p>Generate noisy data from unknown (and possibly known) parameter distributions.</p><p><strong>Arguments</strong></p><ul><li><code>rng::AbstractRNG = Random.GLOBAL_RNG</code>: Random number generator to use</li><li><code>N::Integer</code>: Number of data points</li><li><code>xDists</code>: Distributions of latent parameters [L] or scalar (if L = 1); <code>xDists</code> can be any object such that <code>rand(xDists, ::Integer)</code> is defined (or a collection of such objects)</li><li><code>νDists</code>: Distributions of known parameters [K] or scalar (if K = 1); <code>νDists</code> can be any object such that <code>rand(νDists, ::Integer)</code> is defined (or a collection of such objects); omit this parameter if K = 0</li><li><code>noiseDist</code>: Distribution of noise (assumes same noise distribution for both real and imaginary channels in complex case); <code>noiseDist</code> can be any object such that <code>rand(noiseDist, ::Integer)</code> is defined</li><li><code>signalModels::Union{&lt;:Function,&lt;:AbstractVector{&lt;:Function}}</code>: Signal models used to generate noiseless data [numSignalModels]; each signal model accepts as inputs L latent parameters (scalars) first, then K known parameters (scalars); user-defined parameters (e.g., scan parameters in MRI) should be built into the signal model</li></ul><p><strong>Return</strong></p><ul><li><code>y::Union{&lt;:AbstractVector{&lt;:Number},&lt;:AbstractMatrix{&lt;:Number}}</code>: Output data of all the (simulated) signals [D,N] or [N] (if D = 1)</li><li><code>x::Union{&lt;:AbstractVector{&lt;:Real},&lt;:AbstractMatrix{&lt;:Real}}</code>: Randomly generated latent parameters [L,N] or [N] (if L = 1)</li><li><code>ν::Union{&lt;:AbstractVector{&lt;:Real},&lt;:AbstractMatrix{&lt;:Real}}</code>: Randomly generated known parameters [K,N] or [N] (if K = 1); not returned if <code>νDists</code> is omitted</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StevenWhitaker/PERK.jl/blob/2780883ddfbe65d460b42dc4e89bbb9a9454a97c/src/training.jl#L289-L320">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PERK.holdout-Tuple{Random.AbstractRNG, Integer, Integer, AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}, AbstractVector, AbstractVector, Any, Union{Function, AbstractVector{&lt;:Function}}, Function}" href="#PERK.holdout-Tuple{Random.AbstractRNG, Integer, Integer, AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}, AbstractVector, AbstractVector, Any, Union{Function, AbstractVector{&lt;:Function}}, Function}"><code>PERK.holdout</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">holdout([rng], N, T, λvals, ρvals, [weights,] xDistsTest, xDistsTrain,
        noiseDist, signalModels, kernelgenerator; showprogress)
holdout([rng], N, T, λvals, ρvals, [weights,] xDistsTest, νDistsTest,
        xDistsTrain, νDistsTrain, noiseDist, signalModels, kernelgenerator;
        showprogress)</code></pre><p>Select λ and ρ via a holdout process.</p><p><strong>Arguments</strong></p><ul><li><code>rng::AbstractRNG = Random.GLOBAL_RNG</code>: Random number generator to use</li><li><code>N::Integer</code>: Number of test points</li><li><code>T::Integer</code>: Number of training points</li><li><code>λvals::AbstractVector{&lt;:Real}</code>: Values of λ to search over [nλ]</li><li><code>ρvals::AbstractVector{&lt;:Real}</code>: Values of ρ to search over [nρ]</li><li><code>weights::AbstractVector{&lt;:Real}</code>: Weights for calculating holdout cost [L]; omit if L = 1</li><li><code>xDistsTest</code>: Distributions of latent parameters [L] or scalar (if L = 1); <code>xDists</code> can be any object such that <code>rand(xDists, ::Integer)</code> is defined (or a collection of such objects)</li><li><code>νDistsTest</code>: Distributions of known parameters [K] or scalar (if K = 1); <code>νDists</code> can be any object such that <code>rand(νDists, ::Integer)</code> is defined (or a collection of such objects); omit this parameter if K = 0</li><li><code>xDistsTrain</code>: Distributions of latent parameters [L] or scalar (if L = 1); <code>xDists</code> can be any object such that <code>rand(xDists, ::Integer)</code> is defined (or a collection of such objects)</li><li><code>νDistsTrain</code>: Distributions of known parameters [K] or scalar (if K = 1); <code>νDists</code> can be any object such that <code>rand(νDists, ::Integer)</code> is defined (or a collection of such objects); omit this parameter if K = 0</li><li><code>noiseDist</code>: Distribution of noise (assumes same noise distribution for both real and imaginary channels in complex case); <code>noiseDist</code> can be any object such that <code>rand(noiseDist, ::Integer)</code> is defined</li><li><code>signalModels::Union{&lt;:Function,&lt;:AbstractVector{&lt;:Function}}</code>: Signal models used to generate noiseless data [numSignalModels]; each signal model accepts as inputs L latent parameters (scalars) first, then K known parameters (scalars); user-defined parameters (e.g., scan parameters in MRI) should be built into the signal model</li><li><code>kernelgenerator::Function</code>: Function that creates a <code>Kernel</code> object given a vector <code>Λ</code> of lengthscales</li><li><code>showprogress::Bool = false</code>: Whether to show progress</li></ul><p><strong>Note</strong></p><ul><li>L is the number of unknown or latent parameters to be estimated</li><li>K is the number of known parameters</li><li>nλ is the number of λ values to try</li><li>nρ is the number of ρ values to try</li></ul><p><strong>Return</strong></p><ul><li><code>λ::Real</code>: Bandwidth scaling parameter</li><li><code>ρ::Real</code>: Tikhonov regularization parameter</li><li><code>Ψ::AbstractMatrix{&lt;:Real}</code>: Holdout costs for λvals and ρvals [nλ,nρ]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StevenWhitaker/PERK.jl/blob/2780883ddfbe65d460b42dc4e89bbb9a9454a97c/src/holdout.jl#L1-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PERK.krr-Tuple{Union{Real, AbstractMatrix{&lt;:Real}, AbstractVector{&lt;:Real}}, PERK.ExactTrainingData, PERK.ExactKernel}" href="#PERK.krr-Tuple{Union{Real, AbstractMatrix{&lt;:Real}, AbstractVector{&lt;:Real}}, PERK.ExactTrainingData, PERK.ExactKernel}"><code>PERK.krr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">krr(ytest, trainData, kernel)</code></pre><p>Predict latent parameters that generated <code>ytest</code> using kernel ridge regression.</p><p><strong>Arguments</strong></p><ul><li><code>ytest::Union{&lt;:Real,&lt;:AbstractVector{&lt;:Real},&lt;:AbstractMatrix{&lt;:Real}}</code>: Observed test data [Q,N] or [N] (if Q = 1) or scalar (if Q = N = 1)</li><li><code>trainData::TrainingData</code>: Training data</li><li><code>kernel::Kernel</code>: Kernel to use</li></ul><p><strong>Notes</strong></p><ul><li>Q is the number of observed features per test sample</li><li>N is the number of test samples</li></ul><p><strong>Return</strong></p><ul><li><code>xhat::Union{&lt;:Real,&lt;:AbstractVector{&lt;:Real},&lt;:AbstractMatrix{&lt;:Real}}</code>: Estimated latent parameters [L,N] or [N] (if L = 1) or [L] (if N = 1) or scalar (if L = N = 1)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StevenWhitaker/PERK.jl/blob/2780883ddfbe65d460b42dc4e89bbb9a9454a97c/src/krr.jl#L223-L242">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PERK.krr_train-Tuple{AbstractVector{&lt;:Real}, Union{AbstractMatrix{&lt;:Real}, AbstractVector{&lt;:Real}}, PERK.ExactKernel, Real}" href="#PERK.krr_train-Tuple{AbstractVector{&lt;:Real}, Union{AbstractMatrix{&lt;:Real}, AbstractVector{&lt;:Real}}, PERK.ExactKernel, Real}"><code>PERK.krr_train</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">krr_train([rng], xtrain, ytrain, kernel, ρ)
krr_train(xtrain, ytrain, kernel, ρ, f, phase)</code></pre><p>Train kernel ridge regression.</p><p><strong>Arguments</strong></p><ul><li><code>rng::AbstractRNG = Random.GLOBAL_RNG</code>: Random number generator to use (only used when <code>kernel isa RFFKernel</code>)</li><li><code>xtrain::Union{&lt;:AbstractVector{&lt;:Real},&lt;:AbstractMatrix{&lt;:Real}}</code>: Latent parameters for training data [L,T] or [T] (if L = 1)</li><li><code>ytrain::Union{&lt;:AbstractVector{&lt;:Real},&lt;:AbstractMatrix{&lt;:Real}}</code>: Features for training data [Q,T] or [T] (if Q = 1)</li><li><code>kernel::Kernel</code>: Kernel to use</li><li><code>ρ::Real</code>: Tikhonov regularization parameter</li><li><code>f::Union{&lt;:AbstractVector{&lt;:Real},AbstractMatrix{&lt;:Real}} = randn(kernel.H, Q)</code>: Unscaled random frequency values [H,Q] or [H] (if Q = 1) (used when <code>kernel isa RFFKernel</code>)</li><li><code>phase::AbstractVector{&lt;:Real} = rand(kernel.H)</code>: Random phase values [H] (used when <code>kernel isa RFFKernel</code>)</li></ul><p><strong>Note</strong></p><ul><li>L is the number of unknown or latent parameters to be predicted</li><li>Q is the number of observed features per training sample</li><li>T is the number of training samples</li><li>H is approximation order for kernels that use random Fourier features</li></ul><p><strong>Return</strong></p><ul><li><code>trainData::TrainingData</code>: <code>TrainingData</code> object to be passed to <code>krr</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StevenWhitaker/PERK.jl/blob/2780883ddfbe65d460b42dc4e89bbb9a9454a97c/src/krr.jl#L8-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PERK.perk-Tuple{Random.AbstractRNG, Union{Number, AbstractMatrix{&lt;:Number}, AbstractVector{&lt;:Number}}, Integer, Any, Any, Union{Function, AbstractVector{&lt;:Function}}, PERK.Kernel, Real}" href="#PERK.perk-Tuple{Random.AbstractRNG, Union{Number, AbstractMatrix{&lt;:Number}, AbstractVector{&lt;:Number}}, Integer, Any, Any, Union{Function, AbstractVector{&lt;:Function}}, PERK.Kernel, Real}"><code>PERK.perk</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">perk([rng], y, T, xDists, noiseDist, signalModels, kernel, ρ)
perk([rng], y, ν, T, xDists, νDists, noiseDist, signalModels, kernel, ρ)</code></pre><p>Train PERK and then estimate latent parameters.</p><p><strong>Arguments</strong></p><ul><li><code>rng::AbstractRNG = Random.GLOBAL_RNG</code>: Random number generator to use</li><li><code>y::Union{&lt;:Number,&lt;:AbstractVector{&lt;:Number},&lt;:AbstractMatrix{&lt;:Number}}</code>: Test data points [D,N] or [N] (if D = 1) or scalar (if D = N = 1)</li><li><code>ν::Union{&lt;:Real,&lt;:AbstractVector{&lt;:Real},&lt;:AbstractMatrix{&lt;:Real}}</code>: Known parameters [K,N] or [N] (if K = 1) or scalar (if K = N = 1); omit this parameter if K = 0</li><li><code>T::Integer</code>: Number of training points</li><li><code>xDists</code>: Distributions of latent parameters [L] or scalar (if L = 1); <code>xDists</code> can be any object such that <code>rand(xDists, ::Integer)</code> is defined (or a collection of such objects)</li><li><code>νDists</code>: Distributions of known parameters [K] or scalar (if K = 1); <code>νDists</code> can be any object such that <code>rand(νDists, ::Integer)</code> is defined (or a collection of such objects); omit this parameter if K = 0</li><li><code>noiseDist</code>: Distribution of noise (assumes same noise distribution for both real and imaginary channels in complex case); <code>noiseDist</code> can be any object such that <code>rand(noiseDist, ::Integer)</code> is defined</li><li><code>signalModels::Union{&lt;:Function,&lt;:AbstractVector{&lt;:Function}}</code>: Signal models used to generate noiseless data [numSignalModels]; each signal model accepts as inputs L latent parameters (scalars) first, then K known parameters (scalars); user-defined parameters (e.g., scan parameters in MRI) should be built into the signal model</li><li><code>kernel::Kernel</code>: Kernel to use</li><li><code>ρ::Real</code>: Tikhonov regularization parameter</li></ul><p><strong>Note</strong></p><ul><li>D is the combined number of outputs from all signal models (e.g., number of scans in MRI)</li><li>K is the number of known parameters</li><li>L is the number of unknown or latent parameters to be estimated</li><li>N is the number of test points (e.g., number of voxels in MRI)</li></ul><p><strong>Return</strong></p><ul><li><code>xhat::Union{&lt;:Real,&lt;:AbstractVector{&lt;:Real},&lt;:AbstractMatrix{&lt;:Real}}</code>: Estimated latent parameters [L,N] or [N] (if L = 1) or [L] (if N = 1) or scalar (if L = N = 1)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StevenWhitaker/PERK.jl/blob/2780883ddfbe65d460b42dc4e89bbb9a9454a97c/src/estimation.jl#L1-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PERK.perk-Tuple{Union{Number, AbstractMatrix{&lt;:Number}, AbstractVector{&lt;:Number}}, PERK.TrainingData, PERK.Kernel}" href="#PERK.perk-Tuple{Union{Number, AbstractMatrix{&lt;:Number}, AbstractVector{&lt;:Number}}, PERK.TrainingData, PERK.Kernel}"><code>PERK.perk</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">perk(y, trainData, kernel)
perk(y, ν, trainData, kernel)</code></pre><p>Estimate latent parameters using the provided training data.</p><p><strong>Arguments</strong></p><ul><li><code>y::Union{&lt;:Number,&lt;:AbstractVector{&lt;:Number},&lt;:AbstractMatrix{&lt;:Number}}</code>: Test data points [D,N] or [N] (if D = 1) or scalar (if D = N = 1)</li><li><code>ν::Union{&lt;:Real,&lt;:AbstractVector{&lt;:Real},&lt;:AbstractMatrix{&lt;:Real}}</code>: Known parameters [K,N] or [N] (if K = 1) or scalar (if K = N = 1); omit this parameter if K = 0</li><li><code>trainData::TrainingData</code>: Training data</li><li><code>kernel::Kernel</code>: Kernel to use</li></ul><p><strong>Return</strong></p><ul><li><code>xhat::Union{&lt;:Real,&lt;:AbstractVector{&lt;:Real},&lt;:AbstractMatrix{&lt;:Real}}</code>: Estimated latent parameters [L,N] or [N] (if L = 1) or [L] (if N = 1) or scalar (if L = N = 1)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StevenWhitaker/PERK.jl/blob/2780883ddfbe65d460b42dc4e89bbb9a9454a97c/src/estimation.jl#L89-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PERK.rffmap-Tuple{AbstractMatrix{&lt;:Real}, AbstractMatrix{&lt;:Real}, AbstractVector{&lt;:Real}}" href="#PERK.rffmap-Tuple{AbstractMatrix{&lt;:Real}, AbstractMatrix{&lt;:Real}, AbstractVector{&lt;:Real}}"><code>PERK.rffmap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rffmap(q, freq, phase)</code></pre><p>Map features to a higher dimensional space via random Fourier features.</p><p><strong>Arguments</strong></p><ul><li><code>q::Union{&lt;:Real,&lt;:AbstractVector{&lt;:Real},&lt;:AbstractMatrix{&lt;:Real}}</code>: Lower-dimensional features [Q,N] or [N] (if Q = 1) or scalar (if Q = N = 1)</li><li><code>freq::Union{&lt;:AbstractVector{&lt;:Real},&lt;:AbstractMatrix{&lt;:Real}</code>: Random frequency values [H,Q] or [H] (if Q = 1)</li><li><code>phase::AbstractVector{&lt;:Real}</code>: Random phase values [H]</li></ul><p><strong>Note</strong></p><ul><li>Q is the number of features</li><li>N is the number of feature vectors in the input</li><li>H is the approximation order for the random Fourier features</li></ul><p><strong>Return</strong></p><ul><li><code>z::Union{&lt;:AbstractVector{&lt;:Real},&lt;:AbstractMatrix{&lt;:Real}}</code>: Higher-dimensional features [H,N] or [H] (if N = 1)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StevenWhitaker/PERK.jl/blob/2780883ddfbe65d460b42dc4e89bbb9a9454a97c/src/kernels.jl#L466-L487">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PERK.train-Tuple{Random.AbstractRNG, Integer, Any, Any, Union{Function, AbstractVector{&lt;:Function}}, PERK.Kernel, Real}" href="#PERK.train-Tuple{Random.AbstractRNG, Integer, Any, Any, Union{Function, AbstractVector{&lt;:Function}}, PERK.Kernel, Real}"><code>PERK.train</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">train([rng], T, xDists, [νDists], noiseDist, signalModels, kernel, ρ)</code></pre><p>Train PERK using simulated training data.</p><p><strong>Arguments</strong></p><ul><li><code>rng::AbstractRNG = Random.GLOBAL_RNG</code>: Random number generator to use</li><li><code>T::Integer</code>: Number of training points</li><li><code>xDists</code>: Distributions of latent parameters [L] or scalar (if L = 1); <code>xDists</code> can be any object such that <code>rand(xDists, ::Integer)</code> is defined (or a collection of such objects)</li><li><code>νDists</code>: Distributions of known parameters [K] or scalar (if K = 1); <code>νDists</code> can be any object such that <code>rand(νDists, ::Integer)</code> is defined (or a collection of such objects); omit this parameter if K = 0</li><li><code>noiseDist</code>: Distribution of noise (assumes same noise distribution for both real and imaginary channels in complex case); <code>noiseDist</code> can be any object such that <code>rand(noiseDist, ::Integer)</code> is defined</li><li><code>signalModels::Union{&lt;:Function,&lt;:AbstractVector{&lt;:Function}}</code>: Signal models used to generate noiseless data [numSignalModels]; each signal model accepts as inputs L latent parameters (scalars) first, then K known parameters (scalars); user-defined parameters (e.g., scan parameters in MRI) should be built into the signal model</li><li><code>kernel::Kernel</code>: Kernel to use</li><li><code>ρ::Real</code>: Tikhonov regularization parameter</li></ul><p><strong>Return</strong></p><ul><li><code>trainData::TrainingData</code>: TrainingData object to be passed to <code>perk</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StevenWhitaker/PERK.jl/blob/2780883ddfbe65d460b42dc4e89bbb9a9454a97c/src/training.jl#L115-L142">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../generated/examples/01-overview/">PERK overview »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.19 on <span class="colophon-date" title="Thursday 7 July 2022 14:23">Thursday 7 July 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
